<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="در این فصل نحوۀ ذخیره سازی چندین مقدار از یک نوع را توسط یک متغیر تنها خواهید آموخت.">

    <title>فصل ششم: حلقه ها و رشته ها</title>

    <!-- Bootstrap core CSS -->
    <link href="../../rtl/bootstrap.min.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="../../css/modern-business.css" rel="stylesheet">
	<link href="../../css/custom.css" rel="stylesheet">
    <link href="../../css/style.css" rel="stylesheet">
    <link href="../../prism/prism.css" rel="stylesheet">
</head>

<body>

  <!-- Navigation -->
    <nav class="navbar fixed-top navbar-expand-lg navbar-dark fixed-top" style="background-color: #0D161C;">
      <div class="container">
	  <a class="navbar-brand" href="http://javababoon.ir" style=" color: #D4B796;">جاوا بابون</a>
      </div>
    </nav>
  <!-- End Of Navigation-->

  <!-- Page Content -->
  <div class="container">
    <div class="row">

      <!-- Blog Entries Column -->
      <div class="col-md-8">

 <div class="card mb-4">
          <div class="card-body">
		  <div style="background-image: linear-gradient(90deg, #D4B796, #807971, #0D161C);">
			  <h1 class="card-title" style="padding: 15px; color: white;">جبر کامپیوتر در جاوا</h1><hr>
		  </div>
		  
            <h5 class="card-title">
			Computer algebra in Java: libraries and scripting
		<br>
		<small>(Authors: Raphael Jolly, Heinz Kredel)</small>
			</h5><hr>				  

چگونه یک زبان اسکریپت نویسی را برای جبر کامپیوتر تبدیل به یک زبان منحصر به زمینه کنیم.
<h4>خلاصه</h4>
ما دو سیستم جبر کامپیوتر 
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">// outer loop: for each lowercase letter
for (char c = 'a'; c <= 'z'; c++) {
// inner loop: count how many times the letter appears
  for (int i = 0; i < str.length(); i++) {
    ...
// if the count is not 0 or 2, return false</code></pre>
<br>
این رویکرد «حلقه های تودرتو» رویکرد بهینه ای نیست، بویژه وقتی که طول رشته زیاد است. برای مثال در رمان «جنگ و صلح» بیش از 3 میلیون کاراکتر وجود دارد.
برای پردازش کل این کتاب، حلقۀ تودرتو باید حدود 80 میلیون بار اجرا شود.
<br><br>
الگوریتم دیگر، مقداردهی اولیه 26 متغیر با مقدار صفر و یکبار چرخش در طول رشته و استفاده از یک گزارۀ if غول پیکر برای به روزرسانی متغیرها برای هر حرف است.
اما چه کسی مایل است 26 متغیر اعلان کند؟<br><br>
اینجا است که آرایه ها پا به عرصه می گذارند. می توانیم با استفاده از فقط یک متغیر، 26 عدد صحیح را ذخیره کنیم. به جای استفاده از یک گزارۀ if برای به روزرسانی هر مقدار،
می توانیم از محاسبه ؟؟ برای به روزرسانی مستقیم nامین مقدار استفاده کنیم. این الگوریتم را در انتهای فصل ارائه می کنیم.
<br><br>
<h3 class="card-title">7.1 ایجاد آرایه ها
	<br>	<small>(Creating Arrays)</small>
	</h2><hr>
یک آرایه دنباله ای از مقادیر است. مقادیر یک آرایه را اعضا یا عناصر (elements) آن آرایه می نامند. می توان آرایه ای از intها، doubleها، Stringها، یا
هر نوع دیگری ساخت، اما تمامی مقادیر یک آرایه باید از یک نوع باشند.
<br><br>
برای ایجاد یک آرایه، باید یک متغیر از نوع آرایه تعریف کنید و سپس خود آرایه را بسازید. نوع آرایه ها مانند نوع های دیگر در جاوا است با این تفاوت که 
پس از اعلان نوع، باید از کروشه ([ ]) استفاده کنید. برای مثال خطوط زیر اعلان می کنند که counts آرایه ای از نوع integer است و values آرایه ای از نوع double است.
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] counts;
double[] values;</code></pre>
<br>
برای ایجاد خود آرایه، باید از عملگر new استفاده کنید که آن را پیشتر در بخش 3.2 دیده اید. عملگر new حافظه ای برای آرایه تخصیص می دهد و
مقدار تمامی اعضای آن را به صورت خودکار برابر با صفر قرار می دهد:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">counts = new int[4];
values = new double[size];</code></pre>
<br>
مقداردهی اول، موجب می شود که counts به آرایه ای حاوی 4 عدد صحیح اشاره کند (refer). مقداردهی دوم، باعث می شود که values به آرایه ای از doubleها اشاره کند،
اما تعداد اعضا بستگی به مقدار size دارد (در هنگام ایجاد آرایه).
<br><br>
البته، همچنین می توانید اعلان متغیر و ایجاد آرایه را تنها در یک خط انجام دهید:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] counts = new int[4];
double[] values = new double[size];</code></pre><br>
می توانید از هر عبارت صحیحی (مادامیکه مقدار آن غیرمنفی باشد) به عنوان سایز آرایه استفاده کنید. برای مثال اگر سعی کنید آرایه ای با 4- عضو بسازید، 
پیغام خطای NegativeArraySizeException دریافت می کنید. آرایه ای با صفر عضو مجاز است و برای هر آرایه ای استفادۀ خاصی وجود دارد.
<br>
آرایه را می توان با دنباله ای از اعضا که با یک کاما از هم جدا شده اند و داخل دو آکولاد قرار دارند مقداردهی اولیه کرد. مانند زیر:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] a = {1, 2, 3, 4};
</code></pre>
<br>
این گزاره متغیر آرایۀ a را می سازد به صورتی که به آرایه ای با چهار عضو اشاره می کند.
<br><br>
<h3 class="card-title">7.2 دستیابی به اعضا
	<br>	<small>(Accessing Elements)</small>
	</h2><hr>
وقتی آرایه ای با استفاده از عمگلر new می سازید، اعضای آن با صفر مقداردهی اولیه می شوند. تصویر 7.1 دیاگرام حافظۀ آرایۀ counts را نشان می دهد.

<br><br>
<img class="" src="../../static/ThinkJava-7/دیاگرام-حافظه-آرایه-جاوا-بابون.png" alt="Card image cap">
<br>
<small><em>تصویر 7.1: دیاگرام حافظه برای آرایه ای از نوع int</em></small>

<br><br>
فلشی که در تصویر میبینید بیانگر این است که مقدار counts به آرایه اشاره می کند (reference). 
<br>
[ترجمۀ reference به «اشاره» در اینجا کاملا با معناست و تصویر ذهنی خوبی از آنچه که reference دادن انجام می دهد در ذهن ایجاد می کند. 
به محض اینکه این تصویر ذهنی ایجاد شد، دیگر نیازی به واژۀ «اشاره» نیست و می توان از همان «رفرنس دادن» هم استفاده کرد. در ترجمۀ این کتاب با توجه 
به متنی که واژۀ reference در آن به کار رفته، در بیشتر جاها از «اشاره کردن» و در برخی موارد از رفرنس دادن استفاده کرده ام.]
<br>
آرایه و متغیری که به آن اشاره می کند را باید دو چیز متفاوت در نظر بگیرید. همچنانکه به زودی خواهید دید، می توانیم متغیر دیگری را به گونه ای
مقداردهی کنیم که به همان آرایه اشاره کند و می توانیم مقدار counts را به گونه ای تغییر دهیم که به آرایۀ دیگری اشاره کند.
<br><br>
اعدادی که به صورت پررنگ داخل باکس ها مشخص شده اند اعضای آرایه هستند. اعداد بیرون باکس ها که به صورت کمرنگ تر مشخص شده اند، ایندکس هایی هستند که
به عنوان شناسه ای برای هر محل [حافظه] در آرایه استفاده می شوند. مانند رشته ها، ایندکس اولین عضو، 0 است نه 1. به این دلیل گاهی اوقات به اولین
عضو آرایه به عنوان «صفرمین» عضو اشاره می کنیم.
<br><br>
عملگر [ ] اعضایی از آرایه را انتخاب می کند:
<br><br>
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">System.out.println("The zeroth element is " + counts[0]);
</code></pre><br>
می توانید از عملگر [ ] در هر جایی از یک عبارت استفاده کنید:
<pre class="" >
<code class="language-PowerShell">counts[0] = 7;
counts[1] = counts[0] * 2;
counts[2]++;
counts[3] -= 60;
</code></pre>

<br>
<img class="" src="../../static/ThinkJava-7/دیاگرام-حافظه2-آرایه-جاوا-بابون.png" alt="Card image cap">
<br>
<small><em>تصویر 7.2: دیاگرام حافظه بعد از استفاده از چند گزارۀ مقداردهی</em></small>
<br><br>
تصویر 7.2 نتیجۀ گزاره های بالا را نشان می دهد. 
<br>
می توانید از هر عبارتی (مادامیکه نوع آن int باشد) به عنوان ایندکس استفاده کنید. یکی از رایج ترین شیوه ها برای نوشتن ایندکس یک آرایه
استفاده از متغیر حلقه است. برای مثال:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int i = 0;
while (i < 4) {
  System.out.println(counts[i]);
  i++;
}
</code></pre><br>
این حلقۀ while از 0 تا 4 می شمارد. اگر i برابر با 4 باشد، شرط نقض می شود و حلقه پایان می یابد. بنابراین بدنۀ حلقه تنها وقتی اجرا می شود که
i برابر با 0، 1، 2، یا 3 باشد. در این مورد اسم متغیر i مخفف «index» است.
<br><br>
هر بار در طول حلقه، از i به عنوان ایندکسی درون آرایه استفاده می کنیم تا عضو iام را نمایش دهیم. این نوع از پردازش آرایه معمولا به صورت یک
حلقۀ for نوشته می شود:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">for (int i = 0; i < 4; i++) {
  System.out.println(counts[i]);
}
</code></pre><br>
تنها ایندکس های مجاز برای آرایۀ counts عبارتند از 3 و 2، 1، 0. اگر ایندکس منفی یا بزرگتر از 3 باشد، خطای ArrayIndexOutOfBoundsException
دریافت می کنید.
<br><br>
<h3 class="card-title">7.3 نمایش آرایه ها
	<br>	<small>(Displaying Arrays)</small>
	</h2><hr>
می توانید از println برای نمایش یک آرایه استفاده کنید اما این کار احتمالا آنچه که انتظارش را دارید را انجام نمی دهد. برای مثال اگر 
آرایه ای مانند زیر را پرینت کنید:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] a = {1, 2, 3, 4};
System.out.println(a);
</code></pre><br>
خروجی چنین چیزی خواهد بود:
<pre class="" >
<code class="language-PowerShell">[I@bf3f7e0
</code></pre>
کروشه ای که در ابتدای خروجی وجود دارد بیانگر این است که این مقدار یک آرایه است، I مخفف «integer» است و باقی خروجی، 
آدرس آرایه در حافظه است.
<br><br>
برای نمایش اعضای آرایه می توانیم این کار را به صورت زیر انجام دهیم:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">public static void printArray(int[] a) {
  System.out.print("{" + a[0]);
  for (int i = 1; i < a.length; i++) {
    System.out.print(", " + a[i]);
  }
  System.out.println("}");
}
</code></pre><br>
با توجه به آرایه ای که پیشتر تعریف کردیم، خروجی متد printArray به اینصورت خواهد بود:
<pre class="" >
<code class="language-PowerShell">{1, 2, 3, 4}
</code></pre>
کتابخانۀ جاوا حاوی کلاسی با نام java.util.Arrays است که متدهایی برای کار با آرایه ها ارائه می کند. یکی از آنها متد toString است که
آرایه را به صورت یک رشته ریترن می کند. بعد از ایمپورت کردن  Arrays می توانیم متد toString را به صورت زیر فراخوانی کنیم:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">System.out.println(Arrays.toString(a));
</code></pre><br>
و خروجی به صورت زیر خواهد بود:
<pre class="" >
<code class="language-PowerShell">[1, 2, 3, 4]
</code></pre>
دقت کنید که Arrays.toString به جای آکولاد از کروشه استفاده می کند. اما این متد شما را از نوشتن متدی مثل printArray بی نیاز می کند.
<br><br>
<h3 class="card-title">7.4 کپی کردن آرایه ها
	<br>	<small>(Copying Arrays)</small>
	</h2><hr>
چنانچه در بخش 7.2 گفته شد، متغیرهای آرایه حاوی اشاره هایی به آرایه ها هستند. وقتی یک متغیر آرایه را مقداردهی می کنید، در واقع آدرس آرایه را کپی می کنید.
البته این کار خود آرایه را کپی نمی کند. برای مثال:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">double[] a = new double[3];
double[] b = a;
</code></pre><br>
<br>
<img class="" src="../../static/ThinkJava-7/کپی آرایه ها در جاوا.png" alt="Card image cap">
<br>
تصویر 7.3: دیاگرام حافظۀ دو متغیر که به یک آرایۀ واحد اشاره می کنند.
<br><br>
گزاره های بالا آرایه ای متشکل از سه عضو double می سازند و چنانچه در تصویر 7.3 مشخص شده است، دو متغیر را به گونه ای اعلان می کنند که هر دو به این آرایه اشاره کنند.
<br>
هر تغییری که در یکی از متغیرها ایجاد شود، در متغیر دیگر نیز منعکس می شود. برای مثال اگر بنویسیم a[0] = 17.0 و سپس b[0] را از برنامه بخواهیم، خروجی 17.0 خواهد بود،
چرا که a و b اسامی مختلفی برای یک چیزند. آنها را گاهی اسامی مستعار (aliases) نیز می نامند.<br><br>
اگر بخواهید خود آرایه را کپی نکنید و نه آدرس آن را، باید آرایه ای جدید بسازید و مانند کد زیر اعضای آرایۀ نخست را در آرایۀ دوم کپی کنید:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">double[] b = new double[3];
for (int i = 0; i < 3; i++) {
  b[i] = a[i];
}
</code></pre><br>
java.util.Arrays متدی به نام copyOf ارائه می کند که این کار را برای شما انجام می دهد. بنابراین می توانید تنها از یک خط کدی که در زیر آمده به جای کد قبلی
استفاده کنید:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">double[] b = Arrays.copyOf(a, 3);
</code></pre><br>
پارامتر دوم عبارت از تعداد اعضایی از آرایه است که می خواهید کپی گنید، بنابراین از متد copyOf همچنین می توانید برای 
کپی کردن تنها بخشی از یک آرایه و نه تمامی آن استفاده کنید. تصویر 7.4 وضعیت متغیرهای آرایه را بعد از فراخوانی Arrays.copyOf 
نشان می دهد:
<br>
<img class="" src="../../static/ThinkJava-7/دیاگرام حافظه بعد از کپی آرایه در جاوا.png" alt="Card image cap">
<br>
تصویر 7.4: دیاگرام حافظۀ دو متغیر که به آرایه هایی متفاوت اشاره می کنند.
<br><br>
مثال هایی که تا کنون داشتیم فقط برای آرایه ای با سه عضو کار می کردند. بهتر است این کد را به گونه ای تعمیم دهیم که برای آرایه هایی با هر اندازه ای کار کند.
می توانیم این کار را با تغییر عدد جادویی 3 به a.length انجام دهیم:
 <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">double[] b = new double[a.length];
for (int i = 0; i < a.length; i++) {
  b[i] = a[i];
}
</code></pre><br>
تمامی آرایه ها دارای ثابتی درونی به نام length هستند که تعداد اعضای آرایه را ذخیره می کنند. بر خلاف ()String.length که یک متد است،
 a.length یک ثابت است. عبارت a.length ممکن است شبیه فراخوانی متد به نظر برسد، اما در اینجا پرانتز و آرگومانی وجود ندارد.<br><br>
 آخرین باری که حلقه اجرا می شود، i برابر با a.length - 1 است، که ایندکس آخرین عضو آرایه است. وقتی i برابر با a.length می شود، شرط از بین می رود
 و بدنۀ حلقه دیگر اجرا نمی شود، که امر مطلوبی است چرا که تلاش برای دسترسی به a[a.length] منجر به خطا خواهد شد.<br><br>
 البته می توانیم حلقه را به Arrays.copyOf و آرگومان دوم آن را به a.length تغییر دهیم. خط زیر همان نتیجه ای را در بر خواهد داشت که در تصویر 7.4 آمده است:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">double[] b = Arrays.copyOf(a, a.length);
</code></pre><br>
کلاس Arrays متدهای مفید دیگری را نیز مانند Arrays.compare، Arrays.equals، Arrays.fill، و Arrays.sort ارائه می کند. java.util.Arrays را در گوگل
جستجو کنید و لحظاتی را به خواندن داکیومنت آن اختصاص دهید.
<br><br>
<h3 class="card-title">7.5 پیمایش آرایه ها
	<br>	<small>(Traversing Arrays)</small>
	</h2><hr>
با استفاده از حلقه ها و چرخش در میان اعضای آرایه ها می توان محاسبات بسیاری را پیاده سازی کرد. چرخش در میان اعضای یک آرایه را پیمایش (traversal) می نامند.
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] a = {1, 2, 3, 4, 5};
for (int i = 0; i < a.length; i++) {
  a[i] *= a[i];
}
</code></pre><br>
مثال فوق یک آرایه را مورد پیمایش قرار داده و هر یک از اعضای آن را مجذور می کند. در انتهای حلقه، مقادیر حلقه عبارتند از  {1, 4, 9, 16, 25}.
<br><br>
الگوی رایج دیگر، جستجو (search) نام دارد که عبارتست از پیمایش یک آرایه و جستجو برای یافتن یک عضو خاص. برای مثال متد زیر یک آرایه
و یک مقدار را به عنوان پارامتر می گیرد و ایندکس آن مقدار را ریترن می کند.
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">public static int search(double[] array, double target) {
  for (int i = 0; i < array.length; i++) {
    if (array[i] == target) {
      return i;
    }
  }
  return -1; // not found
}
</code></pre><br>
اگر مقدار target را در آرایه پیدا کنیم، ایندکس آن را فورا ریترن می کنیم. اگر حلقه بدون یافتن target خارج شود، مقدار 1- را ریترن می کند که مقداری است ویژه
که اشاره به بی نتیجه بودن جستجو دارد. (این کد اساسا همان کار متد  String.indexOf را انجام می دهد.)<br><br>

کد زیر مقدار 1.23 را در آرایه ای جستجو می کند که سومین عضو آن است. از آنجا که ایندکس آرایه از 0 آغاز می شود، خروجی برابر با 2 خواهد بود:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">double[] array = {3.14, -55.0, 1.23, -0.8};
int index = search(array, 1.23);
System.out.println(index);
</code></pre><br>
پیمایش رایج دیگر، عمل تقلیل دادن (reduce) است که آرایه ای از مقادیر را به تنها یک مقدار تقلیل می دهد. برای مثال می توان به عمل جمع یا ضرب
اعضا و مینیمم و ماکسیمم اشاره کرد. متد زیر یک آرایه را می گیرد و مجموع اعضای آن را ریترن می کند.
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">public static double sum(double[] array) {
  double total = 0.0;
  for (int i = 0; i < array.length; i++) {
    total += array[i];
  }
  return total;
}
</code></pre><br>
قبل از حلقه، متغیر total را با 0 مقداردهی اولیه کرده ایم. هر بار در حلقه، یکی از اعضای آرایه را با مقدار total جمع می کنیم. در انتهای حلقه، مقدار total
برابر با مجموع اعضا خواهد بود. منغیری که به این شیوه مورد استفاده قرار می گیرد گاها انباشتگر (accumulator) نامیده می شود چرا که مقدار total را در حال اجرا 
روی هم انباشته می کند. 
<br><br>
<h3 class="card-title">7.6 اعداد تصادفی
	<br>	<small>(Random Numbers)</small>
	</h2><hr>
اغلب برنامه های کامپیوتر هر بار که اجرا می شوند کار مشابهی را انجام می دهند. چنین برنامه هایی را برنامه های معین یا قطعی (deterministic) می نامند. قطعیت (determinism)
غالبا چیز خوبی است چرا که ما انتظار داریم یک محاسبه همیشه حاصلی ثابت داشته باشد. اما در برخی از برنامه های کاربردی، می خواهیم کامپیوتر غیر قابل پیش بینی باشد.
بازی ها مثالی واضح از چنین برنامه هایی هستند، اما برنامه های بسیار زیاد دیگری از جمله شبیه سازی های علمی را نیز می توان نام برد.<br><br>
غیر قطعی (nondeterministic) ساختن یک برنامه کار دشواری است چون برای یک کامپیوتر، تولید اعداد تصادفی واقعی غیر ممکن است. اما الگوریتم هایی برای تولید 
دنباله های غیر قابل پیش بینی که اعداد شبه تصادفی (pseudorandom) نامیده می شوند وجود دارد. این اعداد برای اغلب برنامه ها به همان خوبی اعداد تصادفی [واقعی] کار می کنند.
<br><br>
اگر تمرین 3.4 را انجام داده اید، حتما java.util.Random را که اعدادی شبه تصادفی تولید می کند را دیده اید. متد nextInt یک عدد صحیح n را به عنوان آرگومان می گیرد، 
و یک عدد صحیح تصادفی بین 0 و 1 - n ریترن می کند (؟؟).
<br><br>
اگر یک سری طولانی از اعداد تصادفی تولید کنید، هر یک از مقادیر باید حداقل به طور تقریبی به تعداد مقادیر دیگر ظاهر شود. یک راه برای تست کردن این رفتار nextInt،
تولید تعداد زیادی از مقادیر، ذخیره سازی آنها در یک آرایه، و شمارش تعداد دفعات ظاهر شدن هر یک از مقادیر است.<br><br>

متد زیر آرایه ای از نوع int تعریف می کند و سپس آن را با مقادیری تصادفی بین 0 تا 99 پر می کند. آرگومان متد اندازۀ دلخواه آرایه را مشخص می کند و 
مقدار ریترن شده رفرنسی است به آرایۀ جدید.
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">public static int[] randomArray(int size) {
  Random random = new Random();
  int[] a = new int[size];
  for (int i = 0; i < a.length; i++) {
    a[i] = random.nextInt(100);
  }
  return a;
}
</code></pre><br>
متد main زیر یک آرایه تعریف کرده و با استفاده از متد printArray که در بخش 7.3 دیدید آن را نمایش می دهد. می توانستیم از Arrays.toString
هم استفاده کنیم اما در اینجا بیشتر علاقه داریم به جای کروشه، آکولاد ببینیم:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">public static void main(String[] args) {
  int[] array = randomArray(8);
  printArray(array);
}
</code></pre><br>
هر بار که این برنامه را اجرا می کنید، باید مقادیر متفاوتی را دریافت کنید. خروجی چیزی مانند زیر خواهد بود:
<pre class="" >
<code class="language-PowerShell">{15, 62, 46, 74, 67, 52, 51, 10}
</code></pre>
<br><br>
<h3 class="card-title">7.7 ساخت یک هیستوگرام
	<br>	<small>(Building a Histogram)</small>
	</h2><hr>
اگر این مقادیر نمرات یک آزمون بودند (و البته در اینصورت نمرات بسیار بدی محسوب می شوند)، معلم می تواند آنها را به صورت یک هیستوگرام به
شاگردان عرضه کند. هیستوگرام در آمار به مجموعه ای از شمارنده ها گفته می شود که چگونگی تغییرات در تعداد دفعات وقوع مقادیر را نمایش می دهد.
<br><br>
در مورد نمرات آزمون، ممکن است برای بررسی ؟؟ . برای انجام این کار می توانیم آرایه را پیمایش کنیم و تعداد اعضایی را که در این دامنه قرار می گیرند
را بشماریم.<br><br>
متد زیر یک آرایه و دو عدد صحیح به عنوان پارامتر می گیرد و تعداد اعضایی را که در دامنۀ low تا 1 - high قرار می گیرند را ریترن می کند:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">public static int inRange(int[] a, int low, int high) {
  int count = 0;
  for (int i = 0; i < a.length; i++) {
    if (a[i] >= low && a[i] < high) {
      count++;
    }
  }
  return count;
}
</code></pre><br>
این الگو باید برای شما آشنا به نظر برسد، این همان عمل کاستن است. توجه کنید که low در دامنۀ (=<) قرار دارد اما high در دامنۀ (>) قرار ندارد. 
	این طراحی ما را از اینکه هر نمره را دوبار بشماریم بی نیاز می کند.<br><br>
	اکنون می توانیم تعداد نمرات را در دامنۀ هر رتبه بشماریم. کد زیر را به متد main اضافه می کنیم:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] scores = randomArray(30);
int a = inRange(scores, 90, 100);
int b = inRange(scores, 80, 90);
int c = inRange(scores, 70, 80);
int d = inRange(scores, 60, 70);
int f = inRange(scores, 0, 60);
</code></pre><br>	
در کد بالا تکرار وجود دارد اما تا زمانی که تعداد طبقات کم هستند این تکرار قابل پذیرش است. [در اینجا سعی کرده ام در ترجمه تا حد امکان از همان اصطلاحاتی 
که در آمار توصیفی استفاده می شوند استفاده کنم. نویسنده ها range را به طور واضح به معنی «دامنۀ تغییرات» به معنایی که در آمار توصیفی
می دانیم به کار نبرده اند و در خط اخیر هم آنچه که «تعداد طبقات» ترجمه کرده ام که در طبقه بندی داده ها در آمار توصیفی معنایی مشخص دارد در واقع ترجمۀ
«the number of ranges» است. در این متن range به معنای عمومی «محدوده» به کار رفته است.]. فرض کنید می خواستیم تعداد دفعات رخ داد هر نمرۀ منفرد را بررسی کنیم.
برای این کار باید 100 خط کد می نوشتیم:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int count0 = inRange(scores, 0, 1);
int count1 = inRange(scores, 1, 2);
int count2 = inRange(scores, 2, 3);
...
int count99 = inRange(scores, 99, 100);
</code></pre><br>
آنچه که نیاز داریم شیوه ای برای ذخیره کردن 100 شمارنده است و ترجیحا برای دسترسی به آنها می توانیم از ایندکس استفاده کنیم. 
یک لحظه صبر کنید! آیا این دقیقا همان کاری نیست که یک آرایه انجام می دهد؟<br><br>
قطعه کد زیر آرایه ای از 100 شمارنده می سازد که هر یک مختص یک نمرۀ ممکن (احتمالی) هستند. این کد در میان نمرات می چرخد و با استفاده از
متد inRange تعداد دفعات ظهور هر نمره را می شمارد. سپس نتیجه را در آرایۀ counts ذخیره می کند:
  <pre class="line-numbers" data-src="HelloWorld.java" data-download-link>
<code class="language-java match-braces rainbow-braces">int[] counts = new int[100];
for (int i = 0; i < counts.length; i++) {
  counts[i] = inRange(scores, i, i + 1);
}
</code></pre><br>
توجه کنید که ما داریم از متغیر i حلقه سه بار استفاده می کنیم: به عنوان ایندکس در آرایۀ counts، و در دو آرگومان آخر متد inRange.
<br><br>
این کد کار می کند، اما آنچنان که باید بهینه نیست. هر بار که حلقه متد inRange را فراخوانی می کند، تمام آرایه را مورد پیمایش قرار می دهد. 
؟؟





          </div>
      </div>


      </div>
      <!-- Sidebar Widgets Column -->
      <div class="col-md-4">

        <!-- Side Widget -->
   <div class="card my-4 logoClass">
	<img class="card-img-top rounded mx-auto d-block" src="../../static/image10.png" alt="Card image cap" style="width: 250px;">
	 </div>

        <!-- Categories Widget -->
        <div class="card my-4">
          <h5 class="card-header">فهرست کتاب</h5>
          <div class="card-body">
            <div class="row">
              <div class="col-lg-12">
                <ul class="list-unstyled mb-0">
				<li>
                    <a href="مقدمه.html">مقدمه</a>
				 </li>
                <li>
                    <a href="فصل اول-برنامه نویسی کامپیوتر.html">فصل اول: برنامه نویسی کامپیوتر</a>
				 </li>
				  <li>
                    <a href="فصل دوم-متغیرها و عملگرها.html">فصل دوم: متغیرها و عملگرها</a>
                  </li>
				  <li>
                    <a href="فصل سوم-ورودی و خروجی.html">فصل سوم: ورودی و خروجی</a>
                  </li>
				  	<li>
                    <a href="فصل چهارم-متدها و تست کردن.html">فصل چهارم: متدها و تست کردن</a>
                  </li>
				  	<li>
                    <a href="فصل پنجم-شرطی ها و منطق.html">فصل پنجم: شرطی ها و منطق</a>
                  </li>
				  	<li>
                    <a href="فصل ششم-حلقه ها و رشته ها.html">فصل ششم: حلقه ها و رشته ها</a>
                  </li>
				  	<li>
                    <a href="فصل هفتم-آرایه ها و رفرنس ها.html">فصل هفتم: آرایه ها و رفرنس ها</a>
                  </li>
                </ul>
              </div>

            </div>
          </div>
        </div>
		<!-- End of Categories Widget -->
		
      </div>
    </div>
    <!-- /.row -->
  </div>
  <!-- /.container -->

  <!-- Footer -->
  <footer class="py-2 ">
    <div class="container">
      <p class="m-0 text-center text-white">javababoon.ir</p>
    </div>
    <!-- /.container -->
  </footer>
     <script src="../../rtl/jquery-3.3.1.slim.min.js"></script>
  <!-- Bootstrap core JavaScript -->
  <script src="../../rtl/bootstrap.min.js"></script>
    <!-- prism -->
  <script src="../../prism/prism.js"></script>



</body>

</html>


